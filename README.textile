h1. Cutter

Two-methods-gem I use a lot for simple debugging & performance measuring purposes.

Include it into Gemfile:
  gem 'cutter'

Methods are:

h2. I) #inspect! 

Insert #inspect! method into any of your methods:
<pre>
<code>
  def your_method *your_args
    inspect! {} # this string exactly!    
    ...
  end

  your_method(1,"foo",:bar) => 
  
  method `your_method'
    variables: 
      args: [1, "foo", :bar]
</code>
</pre>

or in more rigorous way:
<pre>
<code>
  def your_another_method(first, second, third, &block)
    inspect!(binding)
  end
  
  your_another_method(1,"foo",:bar) => 
  
  method `your_another_method'
    variables: 
      first: 1
      second: "foo"
      third: :bar
      block: 
</code>
</pre>

Gives simple but nice trace for inspection: method's name and args that were passed to method

With :inspect => true we have self#inspect of class to which method belongs to:
<pre>
<code>
  def method_self_inspect
    ...
    inspect!(:inspect => true) {}
  end

  method_self_inspect(1,2,3,4,5) =>
  
  method: `method_self_inspect'
    called from class: SelfInspectDemo
    variables: 
      name: 1
      args: [2, 3, 4, 5]
      block: 
    self inspection:
      #<SelfInspectDemo:0x82be488 @variable="I'm variable">
</code>
</pre>

And finally :level => N gives caller methods chain (N + 1 caller methods):

<pre>
<code>
  def method_caller_chain
    ...
    inspect!(:level => 2)
  end

  method_caller_chain(1,2,3,4,5) => 
  
  method: `method_caller_chain'
    called from class: RSpec::Core::ExampleGroup::Nested_1::Nested_1
    variables: 
      name: 1
      args: [2, 3, 4, 5]
      block: 
    caller methods: 
      /home/stanislaw/_work_/gems/cutter/spec/inspection/demo_spec.rb:33:in `method_caller_chain'
      /home/stanislaw/_work_/gems/cutter/spec/inspection/demo_spec.rb:40:in `block (3 levels) in <top (required)>' 
      /home/stanislaw/.rvm/gems/ruby-1.9.2-p180@310/gems/rspec-core-2.6.4/lib/rspec/core/example.rb:48:in `instance_eval'
</code>
</pre>

If you want all #inspect! methods fall silent at once, use
  @Cutter::Inspection.quiet!@
To make them sound again do
  @Cutter::Inspection.loud!@

You can clone it and try 
  
  @bundle exec rspec spec/inspection/demo_spec.rb@
  
Very! Very simple!

h2. II) #stamper

<pre>
<code>
Stamper.scope :stan => "testing test_method" do |stan|
  stan.msg _1: 'stamp1'
  stan.msg _2: 'stamp2'
  stan.msg _3: 'stamp3'
end

Stamper.scope :hello => "testing hello part" do |stan|
  stan.msg _1: 'hello stan'
  stan.msg _2: 'nice to see you'
end

v = 32

stamper :stan do |s|
  s.stamp
  s.stamp :_1
  sleep 0.1
  s.stamp :_2
  s.stamp :hello_world
  stamper :hello do |s|
    s.stamp :_1
    sleep 0.1
    s.stamp :_2
  end
  sleep 0.1
  s.stamp "hello world: #{v}" # access var before block
  s.stamp :_3
  sleep 0.1
end

 => 

------------------------------
~ START "testing test_method"
  ~ stamp:       0 ms   
  ~ stamp:       0 ms   stamp1
  ~ stamp:     101 ms   stamp2
  ~ stamp:     101 ms   Hello world
  ------------------------------
  ~ START "testing hello part"
    ~ stamp:       0 ms   hello stan
    ~ stamp:     101 ms   nice to see you
  ~ END   "testing hello part"  
  [101ms]
  ------------------------------
  ~ stamp:     305 ms   Hello world: 32
  ~ stamp:     305 ms   stamp3
~ END   "testing test_method"  
[406ms]
------------------------------
</code>
</pre>

or simply:
<pre>
<code>
def test_method
  stamper {
    piece of code
  }
end
</code>
</pre>

Acts as self.benchmark{} (in Rails) or Benchmark.measure{} (common Ruby) but with stamps in any position in block executed.
It is much simpler to write it quickly than all these Measure-dos.

h2. Contributors

* Stanislaw Pankevich
* Kristian Mandrup

h2. Copyright

Copyright (c) 2011 Stanislaw Pankevich

